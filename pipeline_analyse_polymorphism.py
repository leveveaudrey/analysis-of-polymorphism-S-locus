Parameter="parameter.txt"
Parameter = open(str(Parameter), "r")
Parameter=Parameter.read()
Parameter = Parameter.split("\n")

#first, we filter the file of annotation generated by NewAnnotateRef2.py for only interested regions on file csv 

BED=str(Parameter[3])
BED = open(str(BED), "r")
BED=BED.read()
BED = BED.split("\n")

Bed=str(Parameter[1])
Bed = open(str(Bed), "r")
Bed=Bed.read()
Bed = Bed.split("\n")

x2="Annotation_filtered.csv" 
fichier=open(str(x2), "a")
fichier.write("chrom;pos;ref;gene;sens;type")

# if position is correctly annotated and in regions studied => Annotation_filtered.csv
j=1
while j <= len(Bed)-1:
    Bed2=Bed[j]
    Bed2=Bed2.split(" ")
    i=0
    ok=0
    if len(Bed2)==6 and Bed2[3]!="N" :#we keep only the mutations in the coding regions and clearly determine (not ambiguous)
        while ok==0 and i <=len(BED)-1: #we search if in study regions
            BED2=BED[i]
            BED2=BED2.split("\t")
            if int(BED2[1])<=int(Bed2[1]) and int(BED2[2])>=int(Bed2[1]) and BED2[0]==Bed2[0]:ok=1
            else:i=i+1
            
    if ok==1:
        x2=str(Bed2[0])+';'+str(Bed2[1])+';'+str(Bed2[2])+";"+str(Bed2[3])+";"+str(Bed2[4])+';'+str(Bed2[5])#we report the values 
        fichier.write("\n"+str(x2))

    j=j+1

fichier.close()
print("step1_ok")

#secondly, we generate a file than summary all informations

PI=str(Parameter[5]) #  pi VCF tool file
PI = open(str(PI), "r")
PI=PI.read()
PI = PI.split("\n")

DP=str(Parameter[7]) # depth samtool file
DP = open(str(DP), "r")
DP=DP.read()
DP = DP.split("\n")

sequences_comparees=str(Parameter[9])  #  vcf file
sequences_comparees = open(str(sequences_comparees), "r")
sequences_comparees=sequences_comparees.read()
sequences_comparees = sequences_comparees.split("\n")
deb_vcf=0
i=0
deb_vcf2=sequences_comparees[i]
while deb_vcf2[0]=="#":
    i=i+1
    deb_vcf2=sequences_comparees[i]
deb_vcf=i

BED=str(Parameter[3]) # bed file
BED = open(str(BED), "r")
BED=BED.read()
BED = BED.split("\n")

min_depth=float(Parameter[11])
max_depth=float(Parameter[13])

Bed="Annotation_filtered.csv" # file annotation of positions filtrered
Bed = open(str(Bed), "r")
Bed=Bed.read()
Bed = Bed.split("\n")

x2="genom_analysis.csv" 
fichier=open(str(x2), "a")
fichier.write("chrom;pos;annotation;dp;pi;Ho;MAF;idd_minor;nb_SNP")

# if position is in regions studied, present a normal depth, the annotation, mean depth,HO, pi, MAF and  number of SNP found=> genom_analysis.csv

chrom=0
while chrom <= len(BED)-1:
    CHROM=BED[chrom]
    CHROM=CHROM.split("\t")
    deb=int(CHROM[1])
    fin=int(CHROM[2])
    Reg=CHROM[3]
    CHROM=CHROM[0]
    profondeur=[]
    j=0
    while j<=len(DP)-1:
        Bed2=DP[j]
        Bed2=Bed2.split("\t")
        if Bed2[0]== CHROM and int(Bed2[1])<= fin and int(Bed2[1])>= deb  : profondeur.append(Bed2)
        j=j+1
    ok=0
    if len(profondeur)>0:
        ok=1
    if ok==1 : # if cover
        #we filtrered other tables
        annotation=[]
        j=1
        while j <= len(Bed)-1 :
            Bed2=Bed[j]
            Bed2=Bed2.split(";")
            if Bed2[0]== CHROM and int(Bed2[1])<= fin and int(Bed2[1])>= deb  : annotation.append(Bed2)
            j=j+1
        site_pi=[]
        j=1
        while j <= len(PI)-1 :
            Bed2=PI[j]
            Bed2=Bed2.split("\t")
            if Bed2[0]== CHROM and int(Bed2[1])<= fin and int(Bed2[1])>= deb  : site_pi.append(Bed2)
            j=j+1
        VCF=[]
        j=deb_vcf
        while j <= len(sequences_comparees)-1 :
            Bed2=sequences_comparees[j]
            Bed2=Bed2.split("\t")
            if Bed2[0]== CHROM and int(Bed2[1])<= fin and int(Bed2[1])>= deb  : VCF.append(Bed2)
            j=j+1
        # we analyzed each covered regions
        i2=0
        while i2 <=len(profondeur)-1:
            Bed2=profondeur[i2]
            i=int(Bed2[1])
            x="\n"+str(CHROM)+';'+str(i)
            # we determine the mean depth of position
            DEPTH=0
            k=2
            while k <= len(Bed2)-1:
                DEPTH=DEPTH+int(Bed2[k])
                k=k+1
            DEPTH=float(DEPTH/(len(Bed2)-2))
            if DEPTH>=min_depth and DEPTH<=max_depth: # if depth in distribution (min=GATK filtration and max=97.5% of distribution)
                # we determine the annotation of position
                j=0
                ok=0
                ANNOTATION="other"
                while j <= len(annotation)-1:
                    Bed3=annotation[j]
                    if Bed3[0]== CHROM and int(Bed3[1])== i :
                        ok=1
                        ANNOTATION=str(ANNOTATION)+","+str(Bed3[5])
                    j=j+1
                if ok==0 :ANNOTATION="NA"
                # we determine the  pi of position 
                j=0
                ok=0
                while j <= len(site_pi)-1 and ok==0 :
                    Bed3=site_pi[j]
                    if Bed3[0]== CHROM and int(Bed3[1])== i :ok=1
                    j=j+1
                if ok==1 :
                    pi=float(Bed3[2]) #pi tot
                if ok==0 :pi=0
                # we determine the  Ho and MAF of position
                j=0
                ok=0
                while j <= len(VCF)-1 and ok==0 :
                    Bed3=VCF[j]
                    if Bed3[0]== CHROM and int(Bed3[1])== i :ok=1
                    j=j+1
                if ok==0 :
                    ho=0
                    MAF=0
                    ID_MAF="ALT"
                    nb_var=0
                if ok==1 :
                    ho=0 # heterozygotity
                    nb_ind=0
                    k=9
                    while k <= len(Bed3)-1:
                        ind=Bed3[k]
                        ind=ind.split(":")
                        ind=ind[0]
                        if ind!="./.":
                            nb_ind=nb_ind+1
                            ind=ind.split("/")
                            if ind[0]!=ind[1]:ho=ho+1
                        k=k+1
                    ho=float(ho/nb_ind)
                    MAF=[]#minor allele frequency
                    maf=0
                    nb_var=Bed3[4]
                    nb_var=nb_var.split(",")
                    nb_var2=0
                    while nb_var2<=len(nb_var)-1:
                        nb_ind=0
                        k=9
                        while k <= len(Bed3)-1:
                            ind=Bed3[k]
                            ind=ind.split(":")
                            ind=ind[0]
                            if ind!="./.":
                                nb_ind=nb_ind+1
                                ind=ind.split("/")
                                if int(ind[0])==nb_var2+1:maf=maf+1
                                if int(ind[1])==nb_var2+1:maf=maf+1
                            k=k+1
                        maf=float(maf/(nb_ind*2))
                        MAF.append(maf)
                        nb_var2=nb_var2+1
                    MAF=min(MAF)
                    ID_MAF="ALT"
                    nb_var=len(nb_var)+1
                    if float(MAF)>0.5:
                        MAF=1-float(MAF)
                        ID_MAF="REF"

                
                x=str(x)+';'+str(ANNOTATION)+';'+str(DEPTH)+";"+str(pi)+";"+str(ho)+';'+str(MAF)+';'+str(ID_MAF)+';'+str(nb_var)
                fichier.write(str(x))
        
        
            i2=i2+1

    chrom=chrom+1

fichier.close()
print("step2_ok")

#Then, we analysed the polymorphism parameter on each position filtrered of different regions

PI="genom_analysis.csv" # summary file of each position
PI = open(str(PI), "r")
PI=PI.read()
PI = PI.split("\n")

pop=str(Parameter[17])


parameter=str(Parameter[3]) # bed file
parameter = open(str(parameter), "r")
parameter=parameter.read()
parameter = parameter.split("\n")

Bed=str(Parameter[15]) # SIFT file
Bed = open(str(Bed), "r")
Bed=Bed.read()
Bed = Bed.split("\n")
deb_sift=1


x2="vcf_analysis_distri_"+str(pop)+".csv" 
fichier=open(str(x2), "a")
fichier.write("region;dist;Ho;MAF;frequency_alt;pi;degenerate;SIFT_annotation")

# if position  presents a normal depth, less than  2 variants the annotation,HO, pi, MAF and  prediction by SIFT=> vcf_analysis_distri.csv


chrom=1
CHROM=PI[chrom]
CHROM=CHROM.split(";")
while len(CHROM)>1 : # for each position
    if float(CHROM[3])<=max_depth and int(CHROM[8])<=2: #position with less than two nucleotides founded and normal cover 
        pos=int(CHROM[1])
        
        CHROM2=CHROM[0]
        j=0
        seq=parameter[j]
        seq=seq.split("\t")
        ok=0
        while ok==0 and j<=len(parameter)-1: # only position in interest region
            seq=parameter[j]
            seq=seq.split("\t")
            if seq[0]==CHROM2 and int(seq[1])<=pos and int(seq[2])>=pos :
                ok=1
                Reg=seq[3]
                deb=int(seq[1])
            j=j+1
    

        if ok!=0: 
            ho=float(CHROM[5])
            MAF=float(CHROM[6])
            freq=MAF
            pi_tot=float(CHROM[4])
            pi_0f="other"
            if CHROM[2]!='NA':
                annot=CHROM[2]
                annot=annot.split(",")
                if annot.count("4")>0:pi_0f="4fold"
                if annot.count("2")>0:pi_0f="2fold"
                if annot.count("3")>0:pi_0f="0fold"
            considered_sift="other"
            k=deb_sift
            sift=Bed[k]
            sift=sift.split(";")
            ok2=0
            while len(sift)-1>1 and ok2==0:
                if sift[0]==CHROM2 and int(sift[1])==pos:
                    ok2=1
                    if sift[12]!="NA":
                        if float(sift[12])<=0.05:considered_sift="hd"
                        if float(sift[12])>0.05 and float(sift[12])<=0.5:considered_sift="ld"
                        if CHROM[7]!="ALT" : freq=1-freq
                k=k+1
                sift=Bed[k]
                sift=sift.split(";")


            
            x2=str(Reg)+";"+str(pos-deb)+";"+str(ho)+";"+str(MAF)+";"+str(freq)+';'+str(pi_tot)+';'+str(pi_0f)+";"+str(considered_sift) 
            fichier.write("\n"+str(x2))

    chrom=chrom+1
    if chrom==len(PI): CHROM=""
    if chrom<len(PI): 
        CHROM=PI[chrom]
        CHROM=CHROM.split(";")

print("step3_ok")

            

fichier.close()

#Then, we analysed the mean polymorphism parameter on each different regions


x2="vcf_analysis_mean"+str(pop)+".csv" 
fichier=open(str(x2), "a")
fichier.write("region;beg;end;Ho;MAF;pi;pi0fold;pi4fold;0f/4f;dp;SIFT_score;nb_pos_considered;nb_pos_0f_considered;nb_pos_4f_considered;nb_pos_sift_considered;MAF_0fold;MAF_sift_high_del;MAF_sift_low_del;MAF_sift_del;pi_ld;pi_hd;pi_del;ho_of;ho_del;ho_ld;ho_hd;ho_4fold;MAF_4fold")

# For each regions, mean of HO, pi, MAF of all positions 0 fold, 4 fold and predicted to be deleterious by SIFT than  presents a normal depth and less than  2 variants => vcf_analysis_mean.csv

chrom=0
while chrom <= len(parameter)-1: # for each region
    CHROM=parameter[chrom]
    CHROM=CHROM.split("\t")
    deb=int(CHROM[1])
    fin=int(CHROM[2])
    Reg=CHROM[3]
    CHROM=CHROM[0]
    j=1
    seq=PI[j]
    seq=seq.split(";")
    data=[]
    while len(seq)>1 and j<=len(PI)-2: # we research the first regions 
        if seq[0]==CHROM and int(seq[1])>=deb and int(seq[1])<=fin :data.append(seq)
        j=j+1
        seq=PI[j]
        seq=seq.split(";")    
    if len(data)==0:chrom=chrom+1 # if no position found

    if len(data)!=0:
        MAF_del=0 #ok
        MAF_0f=0 #ok
        MAF_4f=0 #ok
        MAF_hd=0 #ok
        MAF_ld=0 #ok
        pi_hd=0 #ok
        pi_ld=0 #ok
        pi=0 #ok
        ho_0f=0
        ho_4f=0
        ho_del=0
        ho_ld=0
        ho_hd=0
        considered_sift_hd=0 #ok
        considered_sift_0f=0 #ok
        considered_sift_ld=0 #ok
        considered_sift_del=0 #ok
        ho=0
        MAF=0
        pi_tot=0
        pi_0f=0
        pi_4f=0
        SIFT=0
        DP=0
        considered=0
        considered_0f=0
        considered_4f=0
        considered_sift=0
        j=0
        seq=data[j]
        while seq[0]==CHROM and int(seq[1])>=deb and int(seq[1])<=fin and j<=len(data)-2:
            if seq[3]!="NA":
                if float(seq[3])<=max_depth and int(seq[8])<=2: # if normal cover and less than 2 variant found
                    considered=considered+1
                    ho=ho+float(seq[5])
                    DP=DP+float(seq[3])
                    MAF=MAF+float(seq[6])
                    pi_tot=pi_tot+float(seq[4])
                    ANNOT=seq[2]
                    ANNOT=ANNOT.split(",")
                    k=0
                    ok2=0
                    while k<=len(ANNOT)-1 and ok2==0:
                        if ANNOT[k]=="3":
                            MAF_0f=MAF_0f+float(seq[6])
                            ho_0f=ho_0f+float(seq[5])
                            considered_sift_0f=considered_sift_0f+1
                            pi_0f=pi_0f+float(seq[4])
                            considered_0f=considered_0f+1
                            ok2=1
                        if ANNOT[k]=="4":
                            MAF_4f=MAF_4f+float(seq[6])
                            ho_4f=ho_4f+float(seq[5])
                            pi_4f=pi_4f+float(seq[4])
                            considered_4f=considered_4f+1
                            ok2=1
                        k=k+1
                    k=deb_sift
                    sift=Bed[k]
                    sift=sift.split(";")
                    ok2==0
                    while len(sift)-1>1 and ok2==0:
                        if sift[0]==CHROM and int(sift[1])==int(seq[1]):
                            ok2=1
                            if sift[12]!="NA":
                                if seq[7]=="ALT" :
                                    SIFT=SIFT+((float(sift[12])*float(seq[6]))+(1-float(seq[6])))
                                    considered_sift=considered_sift+1
                                if seq[7]!="ALT" :
                                    SIFT=SIFT+((float(sift[12])*(1-float(seq[6]))+float(seq[6])))
                                    considered_sift=considered_sift+1
                                if float(sift[12])<=0.5:
                                    considered_sift_del=considered_sift_del+1
                                    ho_del=ho_del+float(seq[5])
                                    pi=pi+float(seq[4])
                                    if seq[7]=="ALT":
                                        MAF_del=MAF_del+float(seq[6])
                                    if seq[7]!="ALT" :
                                        MAF_del=MAF_del+(1-float(seq[6]))
                                    if float(sift[12])>=0.05:
                                        considered_sift_ld=considered_sift_ld+1
                                        pi_ld=pi_ld+float(seq[4])
                                        ho_ld=ho_ld+float(seq[5])
                                        if seq[7]=="ALT":
                                            MAF_ld=MAF_ld+float(seq[6])
                                        if seq[7]!="ALT" :
                                            MAF_ld=MAF_ld+(1-float(seq[6]))
                                    if float(sift[12])<0.05:
                                        considered_sift_hd=considered_sift_hd+1
                                        pi_hd=pi_hd+float(seq[4])
                                        ho_hd=ho_hd+float(seq[5])
                                        if seq[7]=="ALT":
                                            MAF_hd=MAF_hd+float(seq[6])
                                        if seq[7]!="ALT" :
                                            MAF_hd=MAF_hd+(1-float(seq[6]))
                                
                        k=k+1
                        sift=Bed[k]
                        sift=sift.split(";")

            j=j+1
            seq=data[j]
        if considered_sift_del!=0:
            ho_del=float(ho_del/considered_sift_del)#ok
            MAF_del=float(MAF_del/considered_sift_del)#ok
            pi=float(pi/considered_sift_del)#ok
        if considered_sift_del==0:
            ho_del="NA"
            MAF_del="NA"#ok
            pi="NA"#ok
        if considered_sift_0f!=0:
            ho_0f=float(ho_0f/considered_sift_0f)#ok
            MAF_0f=float(MAF_0f/considered_sift_0f)#ok
        if considered_sift_0f==0:
            MAF_0f="NA"
            ho_0f="NA"
        if considered_sift_ld!=0:
            MAF_ld=float(MAF_ld/considered_sift_ld)#ok
            ho_ld=float(ho_ld/considered_sift_ld)#ok
            pi_ld=float(pi_ld/considered_sift_ld)#ok
        if considered_sift_ld==0:
            ho_ld="NA"
            MAF_ld="NA"
            pi_ld="NA"#ok
        if considered_sift_hd!=0:
            MAF_hd=float(MAF_hd/considered_sift_hd)#ok
            ho_hd=float(ho_hd/considered_sift_hd)#ok
            pi_hd=float(pi_hd/considered_sift_hd)#ok
        if considered_sift_hd==0:
            ho_hd="NA"
            MAF_hd="NA"
            pi_hd="NA"#ok
        if considered!=0:
            ho=float(ho/considered)
            MAF=float(MAF/considered)
            pi_tot=float(pi_tot/considered)
            DP=float(DP/considered)
        if considered==0:
            ho="NA"
            MAF="NA"
            pi_tot="NA"
            DP="NA"
        if considered_0f!=0:pi_0f=float(pi_0f/considered_0f)
        if considered_0f==0:pi_0f=0
        if considered_4f!=0:
            ho_4f=float(ho_4f/considered_4f)#ok
            MAF_4f=float(MAF_4f/considered_4f)#ok
            pi_4f=float(pi_4f/considered_4f)
            if pi_4f!=0:ratio=float(pi_0f/pi_4f)
            if pi_4f==0:ratio="NA"
        if considered_4f==0:
            pi_4f="NA"
            ratio="NA"
        if considered_sift!=0:
            SIFT=float(SIFT/considered_sift)
        if considered_sift==0:
            SIFT="NA"
        x2=str(Reg)+';'+str(deb)+';'+str(fin)+";"+str(ho)+";"+str(MAF)+';'+str(pi_tot)+';'+str(pi_0f)+";"+str(pi_4f)+";"+str(ratio)+";"+str(DP)+";"+str(SIFT)+';'+str(considered)+';'+str(considered_0f)+';'+str(considered_4f)+';'+str(considered_sift)+";"+str(MAF_0f)+';'+str(MAF_hd)+';'+str(MAF_ld)+";"+str(MAF_del)+";"+str(pi_ld)+";"+str(pi_hd)+";"+str(pi)+";"+str(ho_0f)+";"+str(ho_del)+";"+str(ho_ld)+";"+str(ho_hd)+";"+str(ho_4f) +";"+str(MAF_4f)   
        fichier.write("\n"+str(x2))


    chrom=chrom+1

print("step4_ok")


fichier.close()

#we continu with analysis of no control region by individual


parameter=str(Parameter[19]) # fill with windows in interest region
parameter = open(str(parameter), "r")
parameter=parameter.read()
parameter = parameter.split("\n")

Chrom=str(Parameter[21])
deb=int(Parameter[23])
fin=int(Parameter[25])

VCF2=str(Parameter[9])  # vcf file
VCF2 = open(str(VCF2), "r")
VCF2=VCF2.read()
VCF2 = VCF2.split("\n")
VCF=[]
i=deb_vcf
while i <=len(VCF2)-1 and VCF2[i]!="": #each SNP
    seq=VCF2[i]
    seq=seq.split("\t")
    if str(seq[0])==Chrom and int(seq[1])>=deb and int(seq[1])<=fin:VCF.append(seq)
    i=i+1

Sift2=str(Parameter[15]) # sift file
Sift2 = open(str(Sift2), "r")
Sift2=Sift2.read()
Sift2 = Sift2.split("\n")
Sift=[]
i=1
while i <=len(Sift2)-1 and Sift2[i]!="": #each annotated SNP by SIFT
    seq=Sift2[i]
    seq=seq.split(";")
    if str(seq[0])==Chrom and int(seq[1])>=deb and int(seq[1])<=fin:Sift.append(seq)
    i=i+1


    
PI2="genom_analysis.csv" 
PI2 = open(str(PI2), "r")
PI2=PI2.read()
PI2 = PI2.split("\n")
chrom=1
CHROM=PI2[chrom]
CHROM=CHROM.split(";")
PI=[]
while len(CHROM)>1:
    if int(CHROM[1])>=deb and int(CHROM[1])<=fin and str(CHROM[0])==Chrom:PI.append(CHROM)
    chrom=chrom+1
    if chrom==len(PI2): CHROM=""
    if chrom<len(PI2):
        CHROM=PI2[chrom]
        CHROM=CHROM.split(";")

SNPeff=str(Parameter[27]) # SNPeff annotation file
SNPeff = open(str(SNPeff), "r")
SNPeff=SNPeff.read()
SNPeff = SNPeff.split("\n")
SNPeff1=[]
i=0
deb_SNPeff2=SNPeff[i]
while deb_SNPeff2[0]=="#":
    i=i+1
    deb_SNPeff2=SNPeff[i]
deb_SNPeff=i
i=deb_SNPeff
while i <=len(SNPeff)-1 and SNPeff[i]!="": #each SNP
    seq=SNPeff[i]
    seq=seq.split("\t")
    if str(seq[0])==Chrom and int(seq[1])>=deb and int(seq[1])<=fin:SNPeff1.append(seq)
    i=i+1

x2="vcf_analysis_ind_"+str(pop)+".csv" 
fichier=open(str(x2), "a")
fichier.write("region;dist;ind;nb_NS;nb_0fold;nb_cds;nb_mut_0fold;nb_mut_0fold_het;nb_NS_SNPeff;nb_NS_SNPeff_het;nb_del_SIFT;nb_del_SIFT_het") #ici

name=VCF2[deb_vcf-1]
name=name.split("\t")

# For each regions of 2.5kb around the S locus, number of mutations in positions 0 fold, no synonymous (0+2fold) and predicted to be deleterious by SIFT by individual => vcf_analysis_ind_.csv


j=0
while parameter[j]!="":
    P2=parameter[j]
    P2=P2.split("\t")
    deb=int(P2[1])
    fin=int(P2[2])
    Reg=P2[3]
    dist=int(P2[4])
    cds=int(P2[5])
    #number of 0fold positions 
    nb_0fold=0
    i=0
    while i <=len(PI)-1 and PI[i]!="":
        CHROM=PI[i]
        if int(CHROM[1])<=fin and int(CHROM[1])>=deb :
            annot=CHROM[2]
            annot=annot.split(",")
            annot1=annot.count("3")
            annot=annot1
            if annot!=0:nb_0fold=nb_0fold+2
        i=i+1
    #number of no-synonymous positions (2*0fold+2*0.66*2fold), 3fold considerate like 2fold
    nb_NS=0
    i=0
    while i <=len(PI)-1 and PI[i]!="":
        CHROM=PI[i]
        if int(CHROM[1])<=fin and int(CHROM[1])>=deb :
            annot=CHROM[2]
            annot=annot.split(",")
            annot1=annot.count("3")
            annot2=annot.count("2")
            if annot.count("3")!=0:nb_NS=nb_NS+2
            if annot.count("2")!=0:nb_NS=nb_NS+(0.66*2)
        i=i+1  
    if nb_0fold==0 or nb_0fold!=0:
        k=9
        while k<=len(name)-1: #for each individual
            #ici
            het_fold=0
            het_NS=0
            het_del=0
            #jusque la
            fold=0
            NS=0
            Del=0
            ind=name[k]
            i=0
            while i <=len(VCF)-1 and VCF[i]!="": #and each SNP
                seq=VCF[i]
                if  int(seq[1])>=deb and int(seq[1])<=fin: #if in window
                    ALT=seq[4] #if position with only one variant 
                    ALT=ALT.split(",")
                    if len(ALT)==1:
                        pos=int(seq[1])
                        chrom=0
                        CHROM=PI[chrom]
                        ok=0
                        ok2=0
                        while len(CHROM)>1 and ok2==0 :
                            if pos==int(CHROM[1]) :
                                ok2=1
                                if float(CHROM[3])<=max_depth:
                                    ok=1
                                    annot=CHROM[2]
                                    annot=annot.split(",")
                                    annot1=annot.count("3")
                                    annot2=annot.count("2")
                                    annot=annot1+annot2 
                            chrom=chrom+1
                            if chrom<len(PI): 
                                CHROM=PI[chrom]
                            if chrom==len(PI): 
                                CHROM=""
                        if ok!=0: # if normal mean depth
                            genotype=seq[k]
                            genotype=genotype.split(":")
                            genotype=genotype[0]
                            if annot1!=0: # if in 0fold position 
                                if genotype=="0/1": 
                                    fold=fold+1
                                    het_fold=het_fold+1
                                if genotype=="1/1":fold=fold+2
                            if cds!=0:
                                # mutation NS predicted by SNPeff
                                chrom=0
                                CHROM=SNPeff1[chrom]
                                ok2=0
                                while len(CHROM)>1 and ok2==0 : 
                                    if pos==int(CHROM[1]):
                                        ok2=1
                                        SNPEFF=CHROM[7]
                                        SNPEFF=SNPEFF.split("|")
                                        chrom2=1
                                        while chrom2<=len(SNPEFF)-1:
                                            typmut=SNPEFF[chrom2]
                                            typmut=typmut.split("&")
                                            if typmut.count("missense_variant")!=0:
                                                if genotype=="0/1":
                                                    NS=NS+1
                                                    het_NS=het_NS+1
                                                if genotype=="1/1":NS=NS+2
                                            chrom2=chrom2+15
                                    chrom=chrom+1
                                    if chrom<len(SNPeff1): 
                                        CHROM=SNPeff1[chrom]
                                    if chrom==len(SNPeff1): 
                                        CHROM=""
                                #  mutation predicted to be del by sift
                                chrom=0
                                CHROM=Sift[chrom]
                                ok2=0
                                while len(CHROM)>1 and ok2==0 : 
                                    if pos==int(CHROM[1]):
                                        ok2=1
                                        if CHROM[16]=="DELETERIOUS":
                                                if genotype=="0/1": 
                                                    Del=Del+1
                                                    het_del=het_del+1
                                                if genotype=="1/1":Del=Del+2
                                    chrom=chrom+1
                                    if chrom<len(Sift): 
                                        CHROM=Sift[chrom]
                                    if chrom==len(Sift): 
                                        CHROM=""

                i=i+1
                            
            
            if cds==0:x2=str(Reg)+";"+str(dist)+";"+str(ind)+';0;0;0;NA;NA;NA;NA;NA;NA'
            if cds!=0:
                if nb_NS==0:x2=str(Reg)+";"+str(dist)+";"+str(ind)+';0;0;'+str(cds)+';NA;NA;NA;NA;'+str(Del)+';'+str(het_del)
                if nb_0fold==0 and nb_NS!=0:x2=str(Reg)+";"+str(dist)+";"+str(ind)+";"+str(nb_NS)+";0;"+str(cds)+";"+'NA;NA'+';'+str(NS)+';'+str(het_NS)+';'+str(Del)+';'+str(het_del)
                if nb_0fold!=0 and nb_NS!=0:x2=str(Reg)+";"+str(dist)+";"+str(ind)+";"+str(nb_NS)+';'+str(nb_0fold)+";"+str(cds)+";"+str(fold)+';'+str(het_fold)+';'+str(NS)+';'+str(het_NS)+';'+str(Del)+';'+str(het_del)
                
            fichier.write("\n"+str(x2))
            k=k+1
    print(j/len(parameter))
    j=j+1
    

print("step5_ok")


fichier.close()


# we analyzed the tajimaD (ok)

PI2=str(Parameter[29]) # D tajima file
PI2 = open(str(PI2), "r")
PI2=PI2.read()
PI2 = PI2.split("\n")

VCF2=str(Parameter[3]) #bed file
VCF2 = open(str(VCF2), "r")
VCF2=VCF2.read()
VCF2 = VCF2.split("\n")

x2="gene_control_tajima_"+str(pop)+".csv" 
fichier=open(str(x2), "a")
fichier.write("region;beg;end;Dtajima")

#if window of 5kb in bed =>gene_control_tajima_.csv

i=1
while i <= len(PI2)-1 and PI2[i]!="" : 
    region=PI2[i]
    region=region.split("\t")
    fin=int(region[1])+10000
    j=0
    ok=0 # if entierly in bed
    while j <=len(VCF2)-1 and ok==0 and VCF2[j]!="":
        VCF=VCF2[j]
        VCF=VCF.split("\t")
        if region[0]==VCF[0] and int(region[1])>=int(VCF[1]) and fin<= int(VCF[2]) and region[3]!="nan":
            ok=1
            dtaj=region[3]
            deb=region[1]
            Region=VCF[3]
        j=j+1
    if ok==1:
        fichier.write("\n"+str(Region)+";"+str(deb)+";"+str(fin)+";"+str(dtaj))
    
    i=i+1


fichier.close()

